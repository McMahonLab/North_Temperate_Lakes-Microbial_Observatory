{
    "contents" : "# Functions for analyzing the metadata\n\nmake_do_matrix <- function(sampleID, field_data){\n  # Pull out only entries for sample subset\n  find <- grep(sampleID, field_data$Sample_Name)\n  field_data <- field_data[find, ]\n  # Get date and depth information\n  dates <- unique(extract_date(field_data$Sample_Name))\n  depth <- sort(unique(field_data$Depth))\n  # Set up matrix\n  data_matrix <- matrix(0, nrow = length(depth), ncol = length(dates))\n  \n  # Put depths in rows and dates in columns, put data point in correct coordinates\n  for(i in 1:length(depth)){\n    row <- field_data[which(field_data$Depth == depth[i]), ]\n    for(j in 1:length(dates)){\n      col <- row[which(extract_date(row$Sample_Name) == dates[j]), ]\n      data_matrix[i, j] <- col$DO[1]\n    }\n  }\n  # Add labels to matrix and order by date\n  rownames(data_matrix) <- depth\n  colnames(data_matrix) <- as.character(dates)\n  data_matrix <- data_matrix[, order(dates)]\n  \n  # Fill in missing datapoints by averaging depth above and below\n  for(i in 1:(dim(data_matrix)[1] - 1)){\n    for(j in 1:dim(data_matrix)[2]){\n      if(is.na(data_matrix[i, j]) == T){\n        data_matrix[i, j] <- mean(c(data_matrix[i - 1, j], data_matrix[i + 1, j]))\n      }\n    }\n  }\n  #If missing point is the deepest point, take the second deepest point\n  i = dim(data_matrix)[1]\n  for(j in 1:dim(data_matrix)[2]){\n    if(is.na(data_matrix[i, j]) == T){\n      data_matrix[i, j] <- data_matrix[i - 1, j]\n    }\n  } \n  return(data_matrix)\n}\n\nmake_temp_matrix <- function(sampleID, field_data){\n  # Pull out only entries for sample subset\n  find <- grep(sampleID, field_data$Sample_Name)\n  field_data <- field_data[find, ]\n  # Get date and depth information\n  dates <- unique(extract_date(field_data$Sample_Name))\n  depth <- sort(unique(field_data$Depth))\n  # Set up matrix\n  data_matrix <- matrix(0, nrow = length(depth), ncol = length(dates))\n  \n  # Put depths in rows and dates in columns, put data point in correct coordinates\n  for(i in 1:length(depth)){\n    row <- field_data[which(field_data$Depth == depth[i]), ]\n    for(j in 1:length(dates)){\n      col <- row[which(extract_date(row$Sample_Name) == dates[j]), ]\n      data_matrix[i, j] <- col$Temperature[1]\n    }\n  }\n  # Add labels to matrix and order by date\n  rownames(data_matrix) <- depth\n  colnames(data_matrix) <- as.character(dates)\n  data_matrix <- data_matrix[, order(dates)]\n  \n  # Fill in missing datapoints by averaging depth above and below\n  for(i in 1:(dim(data_matrix)[1] - 1)){\n    for(j in 1:dim(data_matrix)[2]){\n      if(is.na(data_matrix[i, j]) == T){\n        data_matrix[i, j] <- mean(c(data_matrix[i - 1, j], data_matrix[i + 1, j]))\n      }\n    }\n  }\n  # If missing point is the deepest point, take the second deepest point\n  i = dim(data_matrix)[1]\n  for(j in 1:dim(data_matrix)[2]){\n    if(is.na(data_matrix[i, j]) == T){\n      data_matrix[i, j] <- data_matrix[i - 1, j]\n    }\n  }\n  \n  return(data_matrix)\n}\n\n# Plot contour water columns\n\nrotate <- function(data_matrix) t(apply(data_matrix, 2, rev))\n\n\nplot_column <- function(data_matrix, title){\n    filled.contour(rotate(data_matrix), ylab = \"Depth (m)\", main = paste(title),\n                 color.palette = colorRampPalette(c(\"blue\", \"cyan\", \"green\", \"yellow\", \"red\")),\n                 plot.axes = {\n                   axis(2, at = seq(from=0, to = 1, length.out = length(rownames(data_matrix))), labels = rev(rownames(data_matrix)))\n                   axis(1, at = seq(from=0, to = 1, length.out = length(colnames(data_matrix))), labels =colnames(data_matrix), cex.axis=0.9, las=2)\n                 }\n  )\n}\n",
    "created" : 1455116063201.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4238875918",
    "id" : "6700EF08",
    "lastKnownWriteTime" : 1455117422,
    "path" : "C:/Users/amlinz16/Desktop/North_Temperate_Lakes-Microbial_Observatory/OTUtable-package/OTUtable/R/water_column_plots.R",
    "project_path" : "R/water_column_plots.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}