---
title: "Supplemental Figures"
author: "Alexandra Linz"
date: "Tuesday, February 9, 2016"
output: pdf_document
---

```{r, Setting_up_the_environment, echo=F, warning=FALSE, message=FALSE}
# Input your path to the North_Temperate_Lakes-Microbial_Observatory/Figures folder in the GitHub repo, or whereever you would like the figures to be saved
path2repo <- "C:/Users/Alex/Desktop/North_Temperate_Lakes-Microbial_Observatory/Figures/"

# Load packages
library(OTUtable)       # Contains data and functions for analysis of NTL-MO OTU table
library(vegan)          # Used for Bray-Curtis
library(ggplot2)        # Used for plotting
library(reshape2)       # Used to format metadata
library(ggdendro)       # Used to plot hierarchical clustering trees
library(exactRankTests) # Used to test evenness across lakes
# Load data from OTUtable
data(otu_table)
data(taxonomy)
data(metadata)

# Generate tables at the clade and phylum level
clade_table <- combine_otus("Clade", otu_table, taxonomy)
phylum_table <- combine_otus("Phylum", otu_table, taxonomy)



```

```{r, Evenness_between_bogs, echo=FALSE, warning=FALSE, message=FALSE}
# List lake categories
lakes <- c("CB", "FB", "WS", "NS", "TB", "SS", "HK", "MA")

# Split epilimnion and hypolimnion into separate tables
epilimnia <- bog_subset("..E", otu_table)
hypolimnia <- bog_subset("..H", otu_table)

# Calculate observed richness
epi.evenness <- apply(epilimnia, 2, pielou)
hypo.evenness <- apply(hypolimnia, 2, pielou)

# Extract sampling location from sample names
epi.lakes <- substr(names(epi.evenness), start = 1, stop = 2)
hypo.lakes <- substr(names(hypo.evenness), start = 1, stop = 2)

#Make dataframe for plotting
epi.data <- data.frame(epi.lakes, epi.evenness)
hypo.data <- data.frame(hypo.lakes, hypo.evenness)
epi.data$epi.lakes <- ordered(epi.data$epi.lakes, levels = lakes)
hypo.data$hypo.lakes <- ordered(hypo.data$hypo.lakes, levels = lakes)

ggplot(data = epi.data, aes(y = epi.evenness, x = epi.lakes, fill = epi.lakes)) + geom_boxplot() + labs(y = "Observed Evenness", x = NULL, title = "Epilimnion") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black")) + theme(axis.text.x = element_text(hjust = 1, size = 16, colour = "black"), axis.title = element_text(size = 18, vjust = 2), axis.text.y = element_text(colour = "black", size = 14), legend.position = "none") + scale_fill_brewer(palette = "Set3")
```

```{r, Evenness_between_bogs2, echo=FALSE, warning=FALSE, message=FALSE}
ggplot(data = hypo.data, aes(y = hypo.evenness, x = hypo.lakes, fill = hypo.lakes)) + geom_boxplot() + labs(y = "Observed Evenness", x = NULL, title = "Hypolimnion") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black")) + theme(axis.text.x = element_text(hjust = 1, size = 16, colour = "black"), axis.title = element_text(size = 18, vjust = 2), axis.text.y = element_text(colour = "black", size = 14), legend.position = "none") + scale_fill_brewer(palette = "Set3") 
```

```{r, evenness_significance, warning=FALSE, message=FALSE, echo=FALSE}

#Check significance using Wilcoxon signed-rank test

lakeids <- levels(epi.data$epi.lakes)
Lake1 <- character(0)
Lake2 <- character(0)
Test <- character(0)
pvalue <- numeric(0)
Interpretation <- character(0)

for (id in lakeids) { 
  x = subset(epi.data, epi.data$epi.lakes == id)
  for (lake in lakeids) {
    y = subset(epi.data, epi.data$epi.lakes == lake)
    result <- wilcox.exact(x$epi.evenness,y$epi.evenness, alternative= "two.sided", conf.level = 0.95)
    Lake1 <- c(Lake1, id)
    Lake2 <- c(Lake2, lake)
    Test <- c(Test, result$method)
    pvalue <- c(pvalue, result$p.value)
    if (result$p.value < 0.05) {
      Interpretation <- c(Interpretation, "Reject Null (difference in median detected)")
    } else {
      Interpretation <- c(Interpretation, "Accept Null (difference in median undetected)")
    }  
  }
}

Wilcoxon.epi <- data.frame(Lake1, Lake2, Test, pvalue, Interpretation)
#print(Wilcoxon.epi)

lakeids <- levels(hypo.data$hypo.lakes)
Lake1 <- character(0)
Lake2 <- character(0)
Test <- character(0)
pvalue <- numeric(0)
Interpretation <- character(0)

for (id in lakeids) { 
  x = subset(hypo.data, hypo.data$hypo.lakes == id)
  for (lake in lakeids) {
    y = subset(hypo.data, hypo.data$hypo.lakes == lake)
    result <- wilcox.exact(x$hypo.evenness,y$hypo.evenness, alternative= "two.sided", conf.level = 0.95)
    Lake1 <- c(Lake1, id)
    Lake2 <- c(Lake2, lake)
    Test <- c(Test, result$method)
    pvalue <- c(pvalue, result$p.value)
    if (result$p.value < 0.05) {
      Interpretation <- c(Interpretation, "Reject Null (difference in median detected)")
    } else {
      Interpretation <- c(Interpretation, "Accept Null (difference in median undetected)")
    }  
  }
}

Wilcoxon.hypo <- data.frame(Lake1, Lake2, Test, pvalue, Interpretation)
#print(Wilcoxon.hypo)

```


```{r, Evenness_over_time, echo=FALSE, warning=FALSE, message=FALSE}

# Identify mixing dates (less than 1 degree of temperature difference between 0.5 meters and maximum sampling depth)
metalakes <- substr(metadata$Sample_Name, start = 1, stop = 3)
metayears <- substr(metadata$Sample_Name, start = 9, stop = 10)
metaTBH <- metadata[which(metalakes == "TBH" & metayears == "07"), c(1,2,4)]
metaTBH <- dcast(metaTBH, Sample_Name~Depth, fun.aggregate=mean)
TBHmixes <- extract_date(metaTBH$Sample_Name[which(metaTBH$"0.5" - metaTBH$"7" < 1)])

# Make dataset of Trout Bog hypolimion samples from 2007
hypo <- bog_subset(paste("TBH", sep = ""), otu_table)
hypo <- year_subset("07", hypo)
#Calculate observed richness
hypo.even <- apply(hypo, 2, pielou)
#Extract sampling date from sample names
hypo.date <- extract_date(colnames(hypo))
#Remove January samples - large gap distracts in plot, and winter samples are not considered in this study
hypo.even <- hypo.even[c(1:32, 35:80)]
hypo.date <- hypo.date[c(1:32, 35:80)]

# Make dataframe for plotting
TB_evenness <- data.frame(hypo.date, hypo.even)
colnames(TB_evenness) <- c("date", "evenness")

ggplot() + geom_line(data = TB_evenness, aes(x = date, y=evenness), size = 1) + labs(title = "Trout Bog", x = NULL, y = "Pielou's Evenness") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black")) + theme(axis.text.x = element_text(hjust = 1, size = 8, colour = "black"), axis.title = element_text(size = 12, vjust = 2), axis.text.y = element_text(colour = "black", size = 8), plot.title = element_text(size = 12, vjust = 2)) + geom_point(data = TB_evenness[match(TBHmixes, TB_evenness$date), ], aes(x = date, y = evenness), size = 5, colour = "red") 
```

```{r, Evenness_over_time2, echo=FALSE, warning=FALSE, message=FALSE}
# Repeat with North Sparkling, 2008
metaNSH <- metadata[which(metalakes == "NSH" & metayears == "08"), c(1,2,4)]
metaNSH <- dcast(metaNSH, Sample_Name~Depth, fun.aggregate=mean)
NSHmixes <- extract_date(metaNSH$Sample_Name[which(metaNSH$"0.5" - metaNSH$"4" < 1)])

#Make dataset of Trout Bog hypolimion samples from 2008
hypo <- bog_subset(paste("NSH", sep = ""), otu_table)
hypo <- year_subset("08", hypo)
#Calculate observed richness
hypo.even <- apply(hypo, 2, pielou)
#Extract sampling date from sample names
hypo.date <- extract_date(colnames(hypo))

#Make dataframe for plotting
NS_evenness <- data.frame(hypo.date, hypo.even)
colnames(NS_evenness) <- c("date", "evenness")

ggplot() + geom_line(data = NS_evenness, aes(x = date, y=evenness), size = 1) + labs(title = "North Sparkling Bog", x = NULL, y = "Pielou's Evenness") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black")) + theme(axis.text.x = element_text(hjust = 1, size = 8, colour = "black"), axis.title = element_text(size = 12, vjust = 2), axis.text.y = element_text(colour = "black", size = 8), plot.title = element_text(size = 12, vjust = 2)) + geom_point(data = NS_evenness[match(NSHmixes, NS_evenness$date), ], aes(x = date, y = evenness), size = 5, colour = "red") 

```


```{r, Phylum_abundance, echo=FALSE, warning=FALSE, message=FALSE}
# Keep only phyla labels in phylum_table
phylum_table <- reduce_names(phylum_table)

# Sum total observations of each phylum in the full dataset and sort by abundance
totals <- rowSums(phylum_table)
totals <- sort(totals)

# Remove the "p__" phylum designation from phylum names. This looks better for plotting.
get.names <- strsplit(names(totals), "p__")
phyla.names <- c()
for(i in 1:length(get.names)){
  phyla.names[i] <- get.names[[i]][2]
}
phyla.names[which(is.na(phyla.names) == T)] <- "unclassified"

# Set up a dataframe for plotting in ggplot2. Set the phyla.names to factors, with levels in order of abundance.
phylum_totals <- data.frame(phyla.names, totals)
phylum_totals$phyla.names <- factor(phylum_totals$phyla.names, levels = phylum_totals$phyla.names[order(phylum_totals$totals)])

# Plot as a bar graph
ggplot(data=phylum_totals, aes(x = phyla.names, y = totals)) + geom_bar(stat = "identity", fill = "grey", colour="black") + labs(x = NULL, y = "Log of Observed Reads") + theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 12, colour = "black"), axis.title = element_text(size = 15, vjust=1.2), plot.title = element_text(size = 20), axis.text.y = element_text(colour="black")) + scale_y_log10(expand = c(0,0)) + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"))

```


```{r, Phylum_barchart, echo=FALSE, message=FALSE, warning=FALSE}
# Specify the sampled layers
layer <- c("CBE", "FBE", "WSE", "NSE", "TBE", "SSE", "HKE", "MAE", "CBH", "FBH", "WSH", "NSH", "TBH",  "SSH", "HKH", "MAH")

# Set up a dataframe with the totals of each phylum for each sampling site
layer.phyla <- rep(NA, dim(phylum_table)[1])

for(i in 1:length(layer)){
  dataset <- bog_subset(layer[i], phylum_table)
  layer.phyla <- cbind(layer.phyla, rowSums(dataset)) 
}

layer.phyla <- layer.phyla[,2:dim(layer.phyla)[2]]
colnames(layer.phyla) <- layer

# Combine low abundance phyla into a single category called "other"
abun <- layer.phyla[which(rowSums(layer.phyla) >= 10000),]
other <- layer.phyla[which(rowSums(layer.phyla) < 10000),]
new.layer <- rbind(abun, colSums(other))

# Shorten up those names again and remove extraneous rownames
get.names <- strsplit(rownames(new.layer), "p__")
phyla.names <- c()
for(i in 1:length(get.names)){
  phyla.names[i] <- get.names[[i]][2]
}
phyla.names[7] <- "unclassifed"
phyla.names[12] <- "other"
phyla.names <- factor(phyla.names, levels = rev(phyla.names))
rownames(new.layer) <- NULL

# Convert data into a long format dataframe for use in ggplot
phyla_by_bog <- data.frame(phyla.names, new.layer)
phyla_by_bog2 <- melt(phyla_by_bog)

# Create color palette that can handle the large number of categories
pal2 = c("#005682", "#edfb48", "#a1a100", "#626262", "#008141", "#008282", "#00d5f2", "#f2a400", "#209401", "#929292", "#3885e7", "#ff8400")

# Plot data as a stacked barplot
ggplot(data=phyla_by_bog2, aes(x=variable, y=value, fill=phyla.names)) + geom_bar(stat="identity", position = "fill") + labs(x = NULL, y = "Proportion of Observed Reads") + theme(axis.text.x = element_text(size = 12, angle = 90, color="black"), axis.text.y = element_text(size=14, color="black"), axis.title = element_text(size = 15, vjust=2), legend.title = element_blank(), legend.text = element_text(size = 16)) + scale_fill_manual(values=rev(pal2)) + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"))  + scale_y_continuous(expand = c(0,0)) 

```

```{r, Rank_abundance:epilimnia, echo=FALSE, warning=FALSE, message=FALSE}
# Keep only epilimnion samples
epi_clade_table <- bog_subset("..E", clade_table)

# Remove taxonomic level tags at the beginning of some names (present in Greengenes classified clades)
rownames(epi_clade_table) <- make.unique(gsub("[kpcofg]__|\\[|\\]|Bacteria;", "", rownames(epi_clade_table)))

# Keep only clades that are completely classified
splitnames<- strsplit(rownames(epi_clade_table), ";")
clades_only <- c()
for(i in 1:length(splitnames)){
  clades_only[i] <- splitnames[[i]][5]
}

epi_clade_table2 <- epi_clade_table[which(clades_only != "unclassified" & is.na(clades_only) == F),]
epi_clade_table2 <- reduce_names(epi_clade_table2)
# Sum total abundances of epilimnion clades
epi_clade_sums <- sort(rowSums(epi_clade_table2), decreasing = T)

# Make dataframe of the 20 most abundant epilimnion clades for plotting
plot_epi_clades <- data.frame(names(epi_clade_sums)[1:20], epi_clade_sums[1:20])
colnames(plot_epi_clades) <- c("Clade", "Abundance")
plot_epi_clades$Clade <- factor(plot_epi_clades$Clade, levels=plot_epi_clades$Clade)
ggplot(data = plot_epi_clades, aes(x = Clade, y = Abundance)) + geom_bar(stat = "identity", fill = "grey", colour = "black") + labs(x = NULL, y = "Observed Reads", title = "Epilimnia") + theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 12, colour = "black"), axis.title = element_text(size = 12, vjust=2), axis.text.y = element_text(colour="black")) + scale_y_continuous(expand = c(0,0)) + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"))
```

```{r, Rankabundance:hypolimnia, echo=FALSE, warning=FALSE, message=FALSE}
# Repeat the same analysis as above on hypolimnion samples, but remove samples where the water column was mixed, as well as all polymictic lake samples.
# I use the metadata file to find samples from mixed days. I define a mixed day as less than 1 degree of temperature difference between 0.5 meters and the maximum sampling depth.

metadata$Sample_Name <- as.character(metadata$Sample_Name)
metalakes <- substr(metadata$Sample_Name, start=1, stop=3)
metayears <- substr(metadata$Sample_Name, start=9, stop=10)

# Identify mixed dates from dimictic lakes
metaTBH <- metadata[which(metalakes == "TBH" & metayears == "07"), c(1,2,4)]
metaTBH <- dcast(metaTBH, Sample_Name~Depth, fun.aggregate=mean)
TBHmixes <- metaTBH$Sample_Name[which(metaTBH$"0.5" - metaTBH$"7" < 1)]

metaNSH <- metadata[which(metalakes == "NSH" & metayears == "07"), c(1,2,4)]
metaNSH <- dcast(metaNSH, Sample_Name~Depth, fun.aggregate=mean)
NSHmixes <- metaNSH$Sample_Name[which(metaNSH$"0.5" - metaNSH$"4" < 1)]

metaSSH <- metadata[which(metalakes == "SSH" & metayears == "07"), c(1,2,4)]
metaSSH <- dcast(metaSSH, Sample_Name~Depth, fun.aggregate=mean)
SSHmixes <- metaSSH$Sample_Name[which(metaSSH$"0.5" - metaSSH$"8" < 1)]

mixes <- c(TBHmixes, NSHmixes, SSHmixes)

# Remove mixed dates from table of dimictic and meromictic hypolimnion samples
hypo_clade_table <- bog_subset("TBH|SSH|NSH|MAH|HKH", clade_table)
hits <- match(mixes, substr(colnames(hypo_clade_table), start = 1, stop = 10))
hypo_clade_table <- hypo_clade_table[, -hits]

# Remove taxonomic level tags at the beginning of some names (present in Greengenes classified clades)
rownames(hypo_clade_table) <- gsub("[kpcofg]__|\\[|\\]|Bacteria;", "", rownames(hypo_clade_table))

# Keep only clades that are completely classified
splitnames<- strsplit(rownames(hypo_clade_table), ";")
clades_only <- c()
for(i in 1:length(splitnames)){
  clades_only[i] <- splitnames[[i]][5]
}

hypo_clade_table2 <- hypo_clade_table[which(clades_only != "unclassified" & is.na(clades_only) == F),]
hypo_clade_table2 <- reduce_names(hypo_clade_table2)

# Plot rank abundance curve for 20 most abundant hypolimnion clades
hypo_clade_sums <- sort(rowSums(hypo_clade_table2), decreasing = T)
plot_hypo_clades <- data.frame(names(hypo_clade_sums)[1:20], hypo_clade_sums[1:20])
colnames(plot_hypo_clades) <- c("Clade", "Abundance")
plot_hypo_clades$Clade <- factor(plot_hypo_clades$Clade, levels=plot_hypo_clades$Clade)
ggplot(data = plot_hypo_clades, aes(x = Clade, y = Abundance)) + geom_bar(stat = "identity", fill = "grey", colour="black") + labs(x = NULL, y = "Observed Reads", title = "Hypolimnia") + theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 12, colour = "black"), axis.title = element_text(size = 12, vjust = 2), axis.text.y = element_text(colour = "black")) + scale_y_continuous(expand = c(0,0)) + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"))
```


```{r, PCoA, echo=FALSE, warning=FALSE, message=FALSE}
hypo <- bog_subset("..H", clade_table)
lakes <- c("CB", "FB", "WS", "NS", "TB", "SS", "HK", "MA")
distance <- vegdist(t(hypo), method = "bray")
groups <- factor(substr(colnames(hypo), start = 1, stop = 2), levels = lakes)
pcoa <- betadisper(distance, groups)
scores <- scores(pcoa)

regime <- c()
regime[which(groups == "CB" | groups == "FB" | groups == "WS")] <- "polymictic"
regime[which(groups == "NS" | groups == "TB" | groups == "SS")] <- "dimictic"
regime[which(groups == "HK" | groups == "MA")] <- "meromictic"

# Make dataframe for plotting
plot.pcoa <- data.frame(groups, scores$sites, regime)
colnames(plot.pcoa) <- c("Lake", "PCoA1", "PCoA2", "Regime")

ggplot(data=plot.pcoa, aes(x = PCoA1, y = PCoA2, color = Lake, shape = Regime)) + geom_point(size=3) + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black")) + theme(axis.text.x = element_text(hjust = 1, size = 12, colour = "black"), axis.title = element_text(size = 15, vjust=0.7), axis.text.y = element_text(colour="black", size=12))



# anosim(t(hypo), groups, permutations = 999, distance = "bray")
# anosim(t(hypo), regime, permutations = 999, distance = "bray")
```



```{r, Connectivity_between_bogs, echo=FALSE, warning=FALSE, message=FALSE}
all.network <- read.table(file = "C:/Users/Alex/Desktop/North_Temperate_Lakes-Microbial_Observatory/Network_analysis/allsamples_network_28Jan16.txt", header = T)
TBH <- bog_subset("TBH", otu_table)
NSH <- bog_subset("NSH", otu_table)
MAH <- bog_subset("MAH", otu_table)
SSH <- bog_subset("SSH", otu_table)
CBH <- bog_subset("CBH", otu_table)

all.edges <- table(c(as.character(all.network$index1), as.character(all.network$index2)))


# Calcuate connectivity metric for each sample by lake
# metric (for each sample) = sum(OTU abundance * # of connections to that OTU * average strength of connections to that OTU)
TBH.nodes <- match(names(all.edges), rownames(TBH))
TBH.conn <- TBH[TBH.nodes,]
TBH.edges <- all.edges[match(rownames(TBH.conn), names(all.edges))]

TBH.corr <- c()
for(i in 1:length(TBH.edges)){
  hits <- which(all.network$index1 == names(TBH.edges)[i] | all.network$index2 == names(TBH.edges)[i])
  TBH.corr[i] <- mean(all.network$LSA[hits])
}
TBH.quant <- TBH.edges * TBH.corr
TBH.metric <- colSums(sweep(TBH.conn, 1, TBH.quant, "*"))
TBH.dates <- extract_date(colnames(TBH))

NSH.nodes <- match(names(all.edges), rownames(NSH))
NSH.conn <- NSH[NSH.nodes,]
NSH.edges <- all.edges[match(rownames(NSH.conn), names(all.edges))]

NSH.corr <- c()
for(i in 1:length(NSH.edges)){
  hits <- which(all.network$index1 == names(NSH.edges)[i] | all.network$index2 == names(NSH.edges)[i])
  NSH.corr[i] <- mean(all.network$LSA[hits])
}
NSH.quant <- NSH.edges * NSH.corr
NSH.metric <- colSums(sweep(NSH.conn, 1, NSH.quant, "*"))
NSH.dates <- extract_date(colnames(NSH))

MAH.nodes <- match(names(all.edges), rownames(MAH))
MAH.conn <- MAH[MAH.nodes,]
MAH.edges <- all.edges[match(rownames(MAH.conn), names(all.edges))]

MAH.corr <- c()
for(i in 1:length(MAH.edges)){
  hits <- which(all.network$index1 == names(MAH.edges)[i] | all.network$index2 == names(MAH.edges)[i])
  MAH.corr[i] <- mean(all.network$LSA[hits])
}
MAH.quant <- MAH.edges * MAH.corr
MAH.metric <- colSums(sweep(MAH.conn, 1, MAH.quant, "*"))
MAH.dates <- extract_date(colnames(MAH))

CBH.nodes <- match(names(all.edges), rownames(CBH))
CBH.conn <- CBH[CBH.nodes,]
CBH.edges <- all.edges[match(rownames(CBH.conn), names(all.edges))]

CBH.corr <- c()
for(i in 1:length(CBH.edges)){
  hits <- which(all.network$index1 == names(CBH.edges)[i] | all.network$index2 == names(CBH.edges)[i])
  CBH.corr[i] <- mean(all.network$LSA[hits])
}
CBH.quant <- CBH.edges * CBH.corr
CBH.metric <- colSums(sweep(CBH.conn, 1, CBH.quant, "*"))
CBH.dates <- extract_date(colnames(CBH))

SSH.nodes <- match(names(all.edges), rownames(SSH))
SSH.conn <- SSH[SSH.nodes,]
SSH.edges <- all.edges[match(rownames(SSH.conn), names(all.edges))]

SSH.corr <- c()
for(i in 1:length(SSH.edges)){
  hits <- which(all.network$index1 == names(SSH.edges)[i] | all.network$index2 == names(SSH.edges)[i])
  SSH.corr[i] <- mean(all.network$LSA[hits])
}
SSH.quant <- SSH.edges * SSH.corr
SSH.metric <- colSums(sweep(SSH.conn, 1, SSH.quant, "*"))
SSH.dates <- extract_date(colnames(SSH))

all.metric <- c(TBH.metric, NSH.metric, MAH.metric, CBH.metric, SSH.metric)
all.dates <- c(TBH.dates, NSH.dates, MAH.dates, CBH.dates, SSH.dates)
lakekey <- c(rep("TBH", length(TBH.metric)), rep("NSH", length(NSH.metric)), rep("MAH", length(MAH.metric)), rep("CBH", length(CBH.metric)), rep("SSH", length(SSH.metric)))
plot.conn <- data.frame(lakekey, all.dates, all.metric)
colnames(plot.conn) <- c("Lake", "Date", "Connectivity")
plot.conn$Lake <- factor(plot.conn$Lake, levels = c("CBH", "NSH", "TBH", "SSH", "MAH"))

ggplot(data = plot.conn, aes(x = Lake, y = Connectivity)) + geom_boxplot() + scale_y_log10() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.text = element_text(colour = "black"))

#Test significant differences
lakeids <- levels(plot.conn$Lake)
Lake1 <- character(0)
Lake2 <- character(0)
Test <- character(0)
pvalue <- numeric(0)
Interpretation <- character(0)

for (id in lakeids) { 
  x = subset(plot.conn, plot.conn$Lake == id)
  for (lake in lakeids) {
    y = subset(plot.conn, plot.conn$Lake == lake)
    result <- wilcox.exact(x$Connectivity,y$Connectivity, alternative= "two.sided", conf.level = 0.95)
    Lake1 <- c(Lake1, id)
    Lake2 <- c(Lake2, lake)
    Test <- c(Test, result$method)
    pvalue <- c(pvalue, result$p.value)
    if (result$p.value < 0.05) {
      Interpretation <- c(Interpretation, "Reject Null (difference in median detected)")
    } else {
      Interpretation <- c(Interpretation, "Accept Null (difference in median undetected)")
    }  
  }
}

Wilcoxon.conn <- data.frame(Lake1, Lake2, Test, pvalue, Interpretation)
# print(Wilcoxon.conn)

```

```{r, hclust_of_all_bogs, echo=FALSE, warning=FALSE, message=FALSE, fig.width=10}
CBH <- bog_subset("CBH", otu_table)
CBH <- CBH[which(rowSums(CBH) > 75), ]
input <- remove_reps(CBH)
month <- substr(colnames(input), start = 6, stop = 8)
input <- input[, which(month == "MAY" | month == "JUN" | month == "AUG" | month == "JUL" | month == "SEP")]
colnames(input) <- substr(colnames(input), start = 4, stop = 10)
h <- hclust(vegdist(t(input), method = "bray"), method = "ward.D2")

ddata <- dendro_data(h, type = "rectangle")
ddata$year <- factor(substr(ddata$label$label, start = 6, stop = 7), levels = c("05", "07", "08", "09"))

ggplot(segment(ddata)) + geom_segment(aes(x = x, y = y, xend = xend, yend = yend)) + theme(axis.text.x = element_text(colour = "black"), axis.text.y = element_text(colour = "black", angle = 90)) + geom_text(data = label(ddata), aes(x = x, y = y, label = label, colour = ddata$year), vjust = 0.5, hjust = 1.1, size = 5, angle = 90)   + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_line(colour="black"), legend.position = "none", axis.text.y = element_text(angle = 0)) + scale_color_manual(values = c("chartreuse4", "darkslategrey", "darkred")) + coord_cartesian(ylim = c(-2, 4)) + labs(title = "Crystal Bog")
```

```{r, hclust_of_all_bogs2, echo=FALSE, warning=FALSE, message=FALSE, fig.width=12}
NSH <- bog_subset("NSH", otu_table)
NSH <- NSH[which(rowSums(NSH) > 75), ]
input <- remove_reps(NSH)
month <- substr(colnames(input), start = 6, stop = 8)
input <- input[, which(month == "MAY" | month == "JUN" | month == "AUG" | month == "JUL" | month == "SEP")]
colnames(input) <- substr(colnames(input), start = 4, stop = 10)
h <- hclust(vegdist(t(input), method = "bray"), method = "ward.D2")

ddata <- dendro_data(h, type = "rectangle")
ddata$year <- factor(substr(ddata$label$label, start = 6, stop = 7), levels = c("05", "07", "08", "09"))

ggplot(segment(ddata)) + geom_segment(aes(x = x, y = y, xend = xend, yend = yend)) + theme(axis.text.x = element_text(colour = "black"), axis.text.y = element_text(colour = "black", angle = 90)) + geom_text(data = label(ddata), aes(x = x, y = y, label = label, colour = ddata$year), vjust = 0.5, hjust = 1.1, size = 4, angle = 90)   + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_line(colour="black"), legend.position = "none", axis.text.y = element_text(angle = 0)) + scale_color_manual(values = c("chartreuse4", "darkslategrey", "darkred")) + coord_cartesian(ylim = c(-2, 6.5)) + labs(title = "North Sparkling Bog")
```

```{r, hclust_of_all_bogs3, echo=FALSE, warning=FALSE, message=FALSE, fig.width=10}
SSH <- bog_subset("SSH", otu_table)
SSH <- SSH[which(rowSums(SSH) > 75), ]
input <- remove_reps(SSH)
month <- substr(colnames(input), start = 6, stop = 8)
input <- input[, which(month == "MAY" | month == "JUN" | month == "AUG" | month == "JUL" | month == "SEP")]
colnames(input) <- substr(colnames(input), start = 4, stop = 10)
h <- hclust(vegdist(t(input), method = "bray"), method = "ward.D2")

ddata <- dendro_data(h, type = "rectangle")
ddata$year <- factor(substr(ddata$label$label, start = 6, stop = 7), levels = c("05", "07", "08", "09"))

ggplot(segment(ddata)) + geom_segment(aes(x = x, y = y, xend = xend, yend = yend)) + theme(axis.text.x = element_text(colour = "black"), axis.text.y = element_text(colour = "black", angle = 90)) + geom_text(data = label(ddata), aes(x = x, y = y, label = label, colour = ddata$year), vjust = 0.5, hjust = 1.1, size = 5, angle = 90)   + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_line(colour="black"), legend.position = "none", axis.text.y = element_text(angle = 0)) + scale_color_manual(values = c("chartreuse4", "darkslategrey", "darkred")) + coord_cartesian(ylim = c(-1.5, 3)) + labs(title = "South Sparkling Bog")

```


```{r, TBH_vs_MAH07, echo=FALSE, warning=FALSE, message=FALSE}
clade_table07 <- year_subset("07", clade_table)
all.hypo <- bog_subset("..H", clade_table07)
TBH <- bog_subset("TBH", all.hypo)
MAH <- bog_subset("MAH", all.hypo)

#Label which lake each sample comes from
groups <- c(rep("Trout", dim(TBH)[2]), rep("Mary", dim(MAH)[2]))
input <- cbind(TBH, MAH)
dates <- extract_date(colnames(input))

#Remove January samples
dates <- dates[c(1:32, 35:130)]
input <- input[,c(1:32, 35:130)]
groups <- groups[c(1:32, 35:130)]

#Run PCoA using Bray-Curtis Similarity as distance metric
distance <- vegdist(t(input), method="bray")
pcoa <- betadisper(distance, groups)
#Extract scores for plotting
scores <- scores(pcoa)
#Make dataframe for plotting
plot.pcoa <- data.frame(groups, as.numeric(dates - dates[78]), scores$sites)
colnames(plot.pcoa) <- c("Lake", "Date", "PCoA1", "PCoA2")

ggplot(data=plot.pcoa, aes(x = PCoA1, y = PCoA2, shape = Lake, color = Date)) + geom_point(size=3) + scale_shape_discrete(solid=T) + scale_colour_gradient2(low = "white", mid = "yellow", high = "red") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black")) + theme(axis.text.x = element_text(hjust = 1, size = 12, colour = "black"), axis.title = element_text(size = 15, vjust=0.7), axis.text.y = element_text(colour="black", size=12))
```


