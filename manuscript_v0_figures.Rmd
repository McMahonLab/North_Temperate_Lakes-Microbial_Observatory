---
title: "Manuscript_v0"
author: "Alex Linz"
date: "Wednesday, December 28, 2016"
output: html_document
---

Using 98% clustered OTUs for this analysis

```{r, setup, echo = F, message = F, warning = F}
library(OTUtable)
library(reshape2)
#library(dplyr)
library(ggplot2)
#library(indicspecies)
library(ape)
library(phyloseq)
library(vegan)
#library(picante)
library(grid)
#library(raster)
#library(ggrepel)
library(VennDiagram)
library(coin)

data(metadata)
data(otu_table)
data(taxonomy)
seqs <- read.dna("C:/Users/Alex/Desktop/North_Temperate_Lakes-Microbial_Observatory/Data/16S_data/bog_repseqs_07Jul15.fasta", format = "fasta")

multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  plots <- c(list(...), plotlist)
  numPlots = length(plots)
  if (is.null(layout)) {
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                     ncol = cols, nrow = ceiling(numPlots/cols))
  }
  if (numPlots==1) {
    print(plots[[1]])   
  } else {
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
    for (i in 1:numPlots) {
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}

d <- dist.dna(seqs, model = "raw")
bogtree <- nj(d)

# Set up phyloseq object to run UniFrac on
OTU <- otu_table(as.matrix(otu_table), taxa_are_rows = T)
TAX <- tax_table(as.matrix(taxonomy))
sampledata <- sample_data(data.frame(Bog = substr(colnames(otu_table), start = 1, stop = 2), Layer = substr(colnames(otu_table), start = 3, stop = 3), Year = substr(colnames(otu_table), start = 9, stop = 10), row.names = colnames(otu_table), stringsAsfactors = F)) 
alldata <- phyloseq(OTU, TAX, sampledata, bogtree)

```


```{r, dispersion, echo = F}
# Approach: calculate unifrac, then run the betadisper() function on different groupings of the data and boxplot their dispersion
x <- UniFrac(alldata, weighted = T, normalize = T)
layer_group <- betadisper(x, substr(labels(x), start = 3, stop = 3))
lakelayer_group <- betadisper(x, substr(labels(x), start = 1, stop = 3))
boxplot(layer_group)
boxplot(lakelayer_group, las = 2)

# Do layers in the same lake have significantly different dispersion?
pairwise.wilcox.test(lakelayer_group$distances, lakelayer_group$group, p.adjust.method = "bonferroni")
# Not different: CB, FB, HK, NS, WS
# Different: MA, SS, TB
# Conclusion: dimictic/meromictic hypolimnia are less variable than epilimnia

```

```{r, cohesion, echo = F}

zero <- function(vec){
  num.zero <- length(which(vec == 0))
  return(num.zero)
}

#create function that averages only negative values in a vector
neg.mean <- function(vector){
  neg.vals <- vector[which(vector < 0)]
  n.mean <- mean(neg.vals)
  return(n.mean)
}

#create function that averages only positive values in a vector
pos.mean <- function(vector){
  pos.vals <- vector[which(vector > 0)]
  p.mean <- mean(pos.vals)
  return(p.mean)
}

pers.cutoff <- 0.10
iter <- 200

lakes <- c("FBE", "CBE", "WSE", "NSE", "TBE", "SSE", "HKE", "MAE", "FBH", "CBH", "WSH", "NSH", "TBH", "SSH", "HKH", "MAH")
###################################################################
for (a in 1:length(lakes)){
  b <- bog_subset(lakes[a], otu_table)
  b <- b[which(rowSums(b) > dim(b)[2]), ]
  c <- as.matrix(b)
  c <- c[rowSums(c) > 0, colSums(c) > 0]
  c <- t(c)
  rowsums.orig <- rowSums(c)
  zero.cutoff <- ceiling(pers.cutoff * dim(c)[1])
  e <- c[ , apply(c, 2, zero) < (dim(c)[1]-zero.cutoff) ]
  rel.d <- e / rowsums.orig
  cor.mat.true <- cor(rel.d)
  med.tax.cors <- vector()
    for(which.taxon in 1:dim(rel.d)[2]){
      perm.cor.vec.mat <- vector()  
      for(i in 1:iter){
        perm.rel.d <- matrix(numeric(0), dim(rel.d)[1], dim(rel.d)[2])
        rownames(perm.rel.d) <- rownames(rel.d)
        colnames(perm.rel.d) <- colnames(rel.d)

        for(j in 1:dim(rel.d)[2]){ 
          perm.rel.d[, j ] <- sample(rel.d[ ,j ]) 
        }
      
        perm.rel.d[, which.taxon] <- rel.d[ , which.taxon]
      
        cor.mat.null <- cor(perm.rel.d)
      
        perm.cor.vec.mat <- cbind(perm.cor.vec.mat, cor.mat.null[, which.taxon])
        }
      med.tax.cors <- cbind(med.tax.cors, apply(perm.cor.vec.mat, 1, median))
      if(which.taxon %% 20 == 0){print(which.taxon)}
      }
  
  obs.exp.cors.mat <- cor.mat.true - med.tax.cors
  diag(obs.exp.cors.mat) <- 0
  connectedness.pos <- apply(obs.exp.cors.mat, 2, pos.mean)
  connectedness.neg <- apply(obs.exp.cors.mat, 2, neg.mean)
  cohesion.pos <- rel.d %*% connectedness.pos
  cohesion.neg <- rel.d %*% connectedness.neg
  output <- list(connectedness.neg, connectedness.pos, cohesion.neg, cohesion.pos)
  names(output) <- c("Negative Connectedness", "Positive Connectedness", "Negative Cohesion", "Positive Cohesion")
  assign(paste(lakes[a], ".results", sep = ""), output)
}

#Make boxplots of connectedness and cohesion by lake, layer, and year
lakekey1 <- c(rep("FBE", length(FBE.results$'Positive Connectedness')), rep("CBE", length(CBE.results$'Positive Connectedness')), rep("WSE", length(WSE.results$'Positive Connectedness')), rep("NSE", length(NSE.results$'Positive Connectedness')), rep("TBE", length(TBE.results$'Positive Connectedness')), rep("SSE", length(SSE.results$'Positive Connectedness')), rep("HKE", length(HKE.results$'Positive Connectedness')), rep("MAE", length(MAE.results$'Positive Connectedness')), rep("FBH", length(FBH.results$'Positive Connectedness')), rep("CBH", length(CBH.results$'Positive Connectedness')), rep("WSH", length(WSH.results$'Positive Connectedness')), rep("NSH", length(NSH.results$'Positive Connectedness')), rep("TBH", length(TBH.results$'Positive Connectedness')), rep("SSH", length(SSH.results$'Positive Connectedness')), rep("HKH", length(HKH.results$'Positive Connectedness')), rep("MAH", length(MAH.results$'Positive Connectedness')))
lakekey2 <- c(rep("FBE", length(FBE.results$'Positive Cohesion')), rep("CBE", length(CBE.results$'Positive Cohesion')), rep("WSE", length(WSE.results$'Positive Cohesion')), rep("NSE", length(NSE.results$'Positive Cohesion')), rep("TBE", length(TBE.results$'Positive Cohesion')), rep("SSE", length(SSE.results$'Positive Cohesion')), rep("HKE", length(HKE.results$'Positive Cohesion')), rep("MAE", length(MAE.results$'Positive Cohesion')), rep("FBH", length(FBH.results$'Positive Cohesion')), rep("CBH", length(CBH.results$'Positive Cohesion')), rep("WSH", length(WSH.results$'Positive Cohesion')), rep("NSH", length(NSH.results$'Positive Cohesion')), rep("TBH", length(TBH.results$'Positive Cohesion')), rep("SSH", length(SSH.results$'Positive Cohesion')), rep("HKH", length(HKH.results$'Positive Cohesion')), rep("MAH", length(MAH.results$'Positive Cohesion')))
pos.con <- c(FBE.results$'Positive Connectedness', CBE.results$'Positive Connectedness', WSE.results$'Positive Connectedness', NSE.results$'Positive Connectedness', TBE.results$'Positive Connectedness', SSE.results$'Positive Connectedness', HKE.results$'Positive Connectedness', MAE.results$'Positive Connectedness', FBH.results$'Positive Connectedness', CBH.results$'Positive Connectedness', WSH.results$'Positive Connectedness', NSH.results$'Positive Connectedness', TBH.results$'Positive Connectedness', SSH.results$'Positive Connectedness', HKH.results$'Positive Connectedness', MAH.results$'Positive Connectedness')
neg.con <- c(FBE.results$'Negative Connectedness', CBE.results$'Negative Connectedness', WSE.results$'Negative Connectedness', NSE.results$'Negative Connectedness', TBE.results$'Negative Connectedness', SSE.results$'Negative Connectedness', HKE.results$'Negative Connectedness', MAE.results$'Negative Connectedness', FBH.results$'Negative Connectedness', CBH.results$'Negative Connectedness', WSH.results$'Negative Connectedness', NSH.results$'Negative Connectedness', TBH.results$'Negative Connectedness', SSH.results$'Negative Connectedness', HKH.results$'Negative Connectedness', MAH.results$'Negative Connectedness')
pos.hes <- c(FBE.results$'Positive Cohesion', CBE.results$'Positive Cohesion', WSE.results$'Positive Cohesion', NSE.results$'Positive Cohesion', TBE.results$'Positive Cohesion', SSE.results$'Positive Cohesion', HKE.results$'Positive Cohesion', MAE.results$'Positive Cohesion', FBH.results$'Positive Cohesion', CBH.results$'Positive Cohesion', WSH.results$'Positive Cohesion', NSH.results$'Positive Cohesion', TBH.results$'Positive Cohesion', SSH.results$'Positive Cohesion', HKH.results$'Positive Cohesion', MAH.results$'Positive Cohesion')
neg.hes <- c(FBE.results$'Negative Cohesion', CBE.results$'Negative Cohesion', WSE.results$'Negative Cohesion', NSE.results$'Negative Cohesion', TBE.results$'Negative Cohesion', SSE.results$'Negative Cohesion', HKE.results$'Negative Cohesion', MAE.results$'Negative Cohesion', FBH.results$'Negative Cohesion', CBH.results$'Negative Cohesion', WSH.results$'Negative Cohesion', NSH.results$'Negative Cohesion', TBH.results$'Negative Cohesion', SSH.results$'Negative Cohesion', HKH.results$'Negative Cohesion', MAH.results$'Negative Cohesion')

connectivity <- data.frame(lakekey1, pos.con, neg.con)
cohesion <- data.frame(lakekey2, pos.hes, neg.hes)
colnames(connectivity) <- colnames(cohesion) <- c("Lake", "Positive", "Negative")

ggplot(data = connectivity, aes(x = Lake, y = Positive)) + geom_boxplot() + theme_bw() + labs(title = "Connectivity")
ggplot(data = connectivity, aes(x = Lake, y = Negative)) + geom_boxplot() + theme_bw() + labs(title = "Connectivity")
ggplot(data = cohesion, aes(x = Lake, y = Positive)) + geom_boxplot() + theme_bw() + labs(title = "Cohesion")
ggplot(data = cohesion, aes(x = Lake, y = Negative)) + geom_boxplot() + theme_bw() + labs(title = "Cohesion")

#While I'm here, analyze the CB mixing results
layer <- c(rep("Epi", length(CBE.results$'Positive Cohesion')), rep("Hypo", length(CBH.results$'Positive Cohesion')))
Pos.Cohesion <- c(CBE.results$'Positive Cohesion', CBH.results$'Positive Cohesion')
dates <- extract_date(c(rownames(CBE.results$'Positive Cohesion'), rownames(CBH.results$'Positive Cohesion')))
year <- c(substr(rownames(CBE.results$'Positive Cohesion'), start = 9, stop = 10), substr(rownames(CBH.results$'Positive Cohesion'), start = 9, stop = 10))
CB.metric <- data.frame(layer, dates, year, Pos.Cohesion)
CB.metric <- CB.metric[order(CB.metric$dates), ]

#Upload buoy data from Crystal

buoy <- read.csv("C:/Users/Alex/Desktop/North_Temperate_Lakes-Microbial_Observatory/Metadata/LTER_data/north_temperate_lakes_lter__daily_water_temperature_-_crystal_bog.csv", header = T)
buoy$sampledate <- as.Date(buoy$sampledate, format = "%Y-%m-%d")
buoy07 <- buoy[which(buoy$year4 == 2007), ]
buoy09 <- buoy[which(buoy$year4 == 2009), ]

# Need to close polygons - add 0 or max values at top and bottom of graph
buoy07 <- buoy07[which(is.na(buoy07$wtemp) == F), ]
# Change range to match cohesion
buoy07$depth <- (buoy07$depth + min(CB.metric$Pos.Cohesion))/(4/0.3)

ggplot() + geom_tile(data = buoy07, aes(x = sampledate, y = depth, fill = wtemp)) + theme_bw() + scale_fill_gradientn(colours = c("dodgerblue", "cyan", "green", "yellow", "red"), "Temp", limits = c(2, 30)) + labs(title = "2007") + scale_y_reverse() + geom_path(data = CB.metric[which(CB.metric$year == "07"), ], aes(x = dates, y = Pos.Cohesion, group = layer))

buoy09 <- buoy09[which(is.na(buoy09$wtemp) == F), ]
# Change range to match cohesion
buoy09$depth <- (buoy09$depth + min(CB.metric$Pos.Cohesion))/(4/0.3)

ggplot() + geom_tile(data = buoy09, aes(x = sampledate, y = depth, fill = wtemp)) + theme_bw() + scale_fill_gradientn(colours = c("dodgerblue", "cyan", "green", "yellow", "red"), "Temp", limits = c(4, 28)) + labs(title = "2009") + scale_y_reverse() + geom_path(data = CB.metric[which(CB.metric$year == "09"), ], aes(x = dates, y = Pos.Cohesion, group = layer))

```

```{r, venn, echo = F}
#First off, any taxa found in all samples?
FWcore <- rownames(otu_table)[which(rowSums(otu_table > 0) == 1387)]
FWcore <- taxonomy[match(FWcore, rownames(taxonomy)), ]
#Otu0097 is PnecC
#What about most samples?
FWcore95 <- rownames(otu_table)[which(rowSums(otu_table > 0) >= 1387*0.95)]
FWcore95 <- taxonomy[match(FWcore95, rownames(taxonomy)), ]
#76, 97, 813 == bacI-A1, PnecC, acI-B2
FWcore90 <- rownames(otu_table)[which(rowSums(otu_table > 0) >= 1387*0.90)]
FWcore90 <- taxonomy[match(FWcore90, rownames(taxonomy)), ]
# add 678 == LD28

epi <- bog_subset("..E", otu_table)
Epicore90 <- rownames(epi)[which(rowSums(epi > 0) >= 671*0.90)]
Epicore90 <- taxonomy[match(Epicore90, rownames(taxonomy)), ]
# 4, 76, 97, 184, 472, 522, 678, 813 == betI, bacI-A1, PnecC, acI-B3, Lhab-A4, alfI-A1, LD28, acI-B2
hypo <- bog_subset("..H", otu_table)
hypocore90 <- rownames(hypo)[which(rowSums(hypo > 0) >= 690*0.90)]
hypocore90 <- taxonomy[match(hypocore90, rownames(taxonomy)), ]
# 42, 53, 76, 97, 189, 813 == Rhodo, unclassified Verruco, bacI-A1, PnecC, acI-B2, acI-B2

#Comparison 1: Epi vs Hypo
epi.vector <- rowSums(bog_subset("..E", otu_table))
hypo.vector <- rowSums(bog_subset("..H", otu_table))
draw.pairwise.venn(area1 = length(which(epi.vector > 0)), area2 = length(which(hypo.vector > 0)), cross.area = length(which(epi.vector > 0 & hypo.vector > 0)), category = c("Epilimnion", "Hypolimnion"))

#Comparison 2: All lakes epi, all lakes hypo
FBE.vector <- rowSums(bog_subset("FBE", otu_table))
CBE.vector <- rowSums(bog_subset("CBE", otu_table))
WSE.vector <- rowSums(bog_subset("WSE", otu_table))
NSE.vector <- rowSums(bog_subset("NSE", otu_table))
TBE.vector <- rowSums(bog_subset("TBE", otu_table))
SSE.vector <- rowSums(bog_subset("SSE", otu_table))
HKE.vector <- rowSums(bog_subset("HKE", otu_table))
MAE.vector <- rowSums(bog_subset("MAE", otu_table))
#How many are shared by all epi?
epicore <- names(FBE.vector)[which(FBE.vector > 0 & CBE.vector > 0 & WSE.vector > 0 & NSE.vector > 0 & TBE.vector > 0 & SSE.vector > 0 & HKE.vector > 0 & MAE.vector > 0)] #110

FBH.vector <- rowSums(bog_subset("FBH", otu_table))
CBH.vector <- rowSums(bog_subset("CBH", otu_table))
WSH.vector <- rowSums(bog_subset("WSH", otu_table))
NSH.vector <- rowSums(bog_subset("NSH", otu_table))
TBH.vector <- rowSums(bog_subset("TBH", otu_table))
SSH.vector <- rowSums(bog_subset("SSH", otu_table))
HKH.vector <- rowSums(bog_subset("HKH", otu_table))
MAH.vector <- rowSums(bog_subset("MAH", otu_table))
#How many are shared by all hypo?
hypocore <- names(FBH.vector)[which(FBH.vector > 0 & CBH.vector > 0 & WSH.vector > 0 & NSH.vector > 0 & TBH.vector > 0 & SSH.vector > 0 & HKH.vector > 0 & MAH.vector > 0)] #130

#Make venn diagrams by mixing regime
grid.newpage()
draw.pairwise.venn(area1 = length(which(HKE.vector > 0)), area2 = length(which(MAE.vector > 0)), cross.area = length(which(HKE.vector > 0 & MAE.vector > 0)), category = c("HKE", "MAE"))
grid.newpage()
draw.pairwise.venn(area1 = length(which(HKH.vector > 0)), area2 = length(which(MAH.vector > 0)), cross.area = length(which(HKH.vector > 0 & MAH.vector > 0)), category = c("HKH", "MAH"))

grid.newpage()
draw.triple.venn(area1 = length(which(FBE.vector > 0)), area2 = length(which(CBE.vector > 0)), area3 = length(which(WSE.vector > 0)), n12 = length(which(FBE.vector > 0 & CBE.vector > 0)), n13 = length(which(FBE.vector > 0 & WSE.vector > 0)), n23 = length(which(WSE.vector > 0 & CBE.vector > 0)), n123 = length(which(FBE.vector > 0 & CBE.vector > 0 & WSE.vector > 0)), category = c("FBE", "CBE", "WSE"))
grid.newpage()
draw.triple.venn(area1 = length(which(FBH.vector > 0)), area2 = length(which(CBH.vector > 0)), area3 = length(which(WSH.vector > 0)), n12 = length(which(FBH.vector > 0 & CBH.vector > 0)), n13 = length(which(FBH.vector > 0 & WSH.vector > 0)), n23 = length(which(WSH.vector > 0 & CBH.vector > 0)), n123 = length(which(FBH.vector > 0 & CBH.vector > 0 & WSH.vector > 0)), category = c("FBH", "CBH", "WSH"))

grid.newpage()
draw.triple.venn(area1 = length(which(NSE.vector > 0)), area2 = length(which(TBE.vector > 0)), area3 = length(which(SSE.vector > 0)), n12 = length(which(NSE.vector > 0 & TBE.vector > 0)), n13 = length(which(NSE.vector > 0 & SSE.vector > 0)), n23 = length(which(SSE.vector > 0 & TBE.vector > 0)), n123 = length(which(NSE.vector > 0 & TBE.vector > 0 & SSE.vector > 0)), category = c("NSE", "TBE", "SSE"))
grid.newpage()
draw.triple.venn(area1 = length(which(NSH.vector > 0)), area2 = length(which(TBH.vector > 0)), area3 = length(which(SSH.vector > 0)), n12 = length(which(NSH.vector > 0 & TBH.vector > 0)), n13 = length(which(NSH.vector > 0 & SSH.vector > 0)), n23 = length(which(SSH.vector > 0 & TBH.vector > 0)), n123 = length(which(NSH.vector > 0 & TBH.vector > 0 & SSH.vector > 0)), category = c("NSH", "TBH", "SSH"))

#Compare epi and hypo by lake
grid.newpage()
draw.pairwise.venn(area1 = length(which(FBE.vector > 0)), area2 = length(which(FBH.vector > 0)), cross.area = length(which(FBE.vector > 0 & FBH.vector > 0)), category = c("FBE", "FBH"))
grid.newpage()
draw.pairwise.venn(area1 = length(which(CBE.vector > 0)), area2 = length(which(CBH.vector > 0)), cross.area = length(which(CBE.vector > 0 & CBH.vector > 0)), category = c("CBE", "CBH"))
grid.newpage()
draw.pairwise.venn(area1 = length(which(WSE.vector > 0)), area2 = length(which(WSH.vector > 0)), cross.area = length(which(WSE.vector > 0 & WSH.vector > 0)), category = c("WSE", "WSH"))
grid.newpage()
draw.pairwise.venn(area1 = length(which(NSE.vector > 0)), area2 = length(which(NSH.vector > 0)), cross.area = length(which(NSE.vector > 0 & NSH.vector > 0)), category = c("NSE", "NSH"))
grid.newpage()
draw.pairwise.venn(area1 = length(which(TBE.vector > 0)), area2 = length(which(TBH.vector > 0)), cross.area = length(which(TBE.vector > 0 & TBH.vector > 0)), category = c("TBE", "TBH"))
grid.newpage()
draw.pairwise.venn(area1 = length(which(SSE.vector > 0)), area2 = length(which(SSH.vector > 0)), cross.area = length(which(SSE.vector > 0 & SSH.vector > 0)), category = c("SSE", "SSH"))
grid.newpage()
draw.pairwise.venn(area1 = length(which(HKE.vector > 0)), area2 = length(which(HKH.vector > 0)), cross.area = length(which(HKE.vector > 0 & HKH.vector > 0)), category = c("HKE", "HKH"))
grid.newpage()
draw.pairwise.venn(area1 = length(which(MAE.vector > 0)), area2 = length(which(MAH.vector > 0)), cross.area = length(which(MAE.vector > 0 & MAH.vector > 0)), category = c("MAE", "MAH"))

# Compare by mixing regime
poly.epi <- FBE.vector > 0 & CBE.vector > 0 & WSE.vector > 0
poly.hypo <- FBH.vector > 0 & CBH.vector > 0 & WSH.vector > 0
di.epi <- NSE.vector > 0 & TBE.vector > 0 & SSE.vector > 0
di.hypo <- NSH.vector > 0 & TBH.vector > 0 & SSH.vector > 0
mero.epi <- HKE.vector > 0 & MAE.vector > 0
mero.hypo <- HKH.vector > 0 & MAH.vector > 0

grid.newpage()
draw.triple.venn(area1 = length(which(poly.epi == T)), area2 = length(which(di.epi == T)), area3 = length(which(mero.epi == T)), n12 = length(which(poly.epi == T & di.epi == T)), n13 = length(which(poly.epi == T & mero.epi == T)), n23 = length(which(mero.epi == T & di.epi == T)), n123 = length(which(poly.epi == T & di.epi == T & mero.epi == T)), category = c("Poly epi", "Di epi", "Mero epi"))

grid.newpage()
draw.triple.venn(area1 = length(which(poly.hypo == T)), area2 = length(which(di.hypo == T)), area3 = length(which(mero.hypo == T)), n12 = length(which(poly.hypo == T & di.hypo == T)), n13 = length(which(poly.hypo == T & mero.hypo == T)), n23 = length(which(mero.hypo == T & di.hypo == T)), n123 = length(which(poly.hypo == T & di.hypo == T & mero.hypo == T)), category = c("Poly hypo", "Di hypo", "Mero hypo"))


```


```{r, zscores, echo = F}
#Do this just on TBE for simplicity
TBE <- bog_subset("TBE", otu_table)
TBE05 <- year_subset("05", TBE)
TBE07 <- year_subset("07", TBE)
TBE08 <- year_subset("08", TBE)
TBE09 <- year_subset("09", TBE)

TBE05 <- zscore(TBE05)
TBE07 <- zscore(TBE07)
TBE08 <- zscore(TBE08)
TBE09 <- zscore(TBE09)
zTBE <- cbind(TBE05, TBE07, TBE08, TBE09)
zTBE <- melt(zTBE)
zTBE$Year <- substr(zTBE$Var2, start = 9, stop = 10)
zTBE$Day <- format(extract_date(zTBE$Var2), format = "%j")

ggplot(data = zTBE[which(zTBE$Var1 == "Otu0097"), ], aes(x = Day, y = value, group = Year, color = Year)) + geom_point() + geom_line() + theme_bw() + labs(title = "Otu0097")

ggplot(data = zTBE[which(zTBE$Var1 == "Otu0002"), ], aes(x = Day, y = value, group = Year, color = Year)) + geom_point() + geom_line() + theme_bw() + labs(title = "Otu0002")

ggplot(data = zTBE[which(zTBE$Var1 == "Otu0005"), ], aes(x = Day, y = value, group = Year, color = Year)) + geom_point() + geom_line() + theme_bw() + labs(title = "Otu0005")

```

```{r, rarefaction, echo = F}

rarefaction <- function(table){
  groups <- c()
  totals <- c()
  table <- table[, sample(ncol(table))]
  for(i in 1:dim(table)[2]){
    groups <- append(groups, rownames(table)[which(table[,i] > 0)], length(groups))
    totals[i] <- length(unique(groups))
  }
  return(totals)
}

TBE.rf <- rarefaction(bog_subset("TBE", otu_table))
plot(TBE.rf, type = "l")
TBH.rf <- rarefaction(bog_subset("TBH", otu_table))
plot(TBH.rf, type = "l")
all.rf <- rarefaction(otu_table)
plot(all.rf, type = "l", main = "Entire Dataset")
epi.rf <- rarefaction(bog_subset("..E", otu_table))
plot(epi.rf, type = "l", main = "Epi")
hypo.rf <- rarefaction(bog_subset("..H", otu_table))
plot(hypo.rf, type = "l", main = "Hypo")
```

```{r, cladelevel, echo = F}
tribe_table <- combine_otus("Tribe", otu_table, taxonomy)
FWcore <- rownames(tribe_table)[which(rowSums(tribe_table > 0) == 1387)]
FWcore

FWcore95 <- rownames(tribe_table)[which(rowSums(tribe_table > 0) >= 1387*0.95)]
FWcore95

FWcore90 <- rownames(tribe_table)[which(rowSums(tribe_table > 0) >= 1387*0.90)]
FWcore90
#Tribe classified only
#bacI-A1, PnecC, betIII-A1, acI-B2, LD28, acI-B4

epi <- bog_subset("..E", tribe_table)
Epicore90 <- rownames(epi)[which(rowSums(epi > 0) >= 671*0.90)]
Epicore90
#bacI-A1, PnecC, betIII-A1, acI-B3, acI-B2, Lhab-A4, alfI-A1, LD28, acI-B4
hypo <- bog_subset("..H", tribe_table)
hypocore90 <- rownames(hypo)[which(rowSums(hypo > 0) >= 690*0.90)]
hypocore90
# Rhodo, bacI-A1, PnecC, betIII-A1, acI-B2, acI-B4

#Unique and shared by mixing regime
FBE.vector <- rowSums(bog_subset("FBE", clade_table))
CBE.vector <- rowSums(bog_subset("CBE", clade_table))
WSE.vector <- rowSums(bog_subset("WSE", clade_table))
NSE.vector <- rowSums(bog_subset("NSE", clade_table))
TBE.vector <- rowSums(bog_subset("TBE", clade_table))
SSE.vector <- rowSums(bog_subset("SSE", clade_table))
HKE.vector <- rowSums(bog_subset("HKE", clade_table))
MAE.vector <- rowSums(bog_subset("MAE", clade_table))
#How many are shared by all epi?
epicore <- names(FBE.vector)[which(FBE.vector > 0 & CBE.vector > 0 & WSE.vector > 0 & NSE.vector > 0 & TBE.vector > 0 & SSE.vector > 0 & HKE.vector > 0 & MAE.vector > 0)] #110

FBH.vector <- rowSums(bog_subset("FBH", clade_table))
CBH.vector <- rowSums(bog_subset("CBH", clade_table))
WSH.vector <- rowSums(bog_subset("WSH", clade_table))
NSH.vector <- rowSums(bog_subset("NSH", clade_table))
TBH.vector <- rowSums(bog_subset("TBH", clade_table))
SSH.vector <- rowSums(bog_subset("SSH", clade_table))
HKH.vector <- rowSums(bog_subset("HKH", clade_table))
MAH.vector <- rowSums(bog_subset("MAH", clade_table))


poly.epi <- FBE.vector > 0 & CBE.vector > 0 & WSE.vector > 0
poly.hypo <- FBH.vector > 0 & CBH.vector > 0 & WSH.vector > 0
di.epi <- NSE.vector > 0 & TBE.vector > 0 & SSE.vector > 0
di.hypo <- NSH.vector > 0 & TBH.vector > 0 & SSH.vector > 0
mero.epi <- HKE.vector > 0 & MAE.vector > 0
mero.hypo <- HKH.vector > 0 & MAH.vector > 0

poly.epi.only <- rownames(clade_table)[which(poly.epi == T & di.epi == F & mero.epi == F)]
di.epi.only <- rownames(clade_table)[which(poly.epi == F & di.epi == T & mero.epi == F)]
mero.epi.only <- rownames(clade_table)[which(poly.epi == F & di.epi == F & mero.epi == T)]

```